\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage[francais]{babel}
\usepackage{listings}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage[export]{adjustbox}
\bibliographystyle{ieeetr}
\author{GAILLARD Valentin FONTENAY Clément CHERIFI Ali}
\title{Rapport de projet\\Programmation système}
\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage

\section{Sauvegarde et chargement des cartes}
La principale source de réflexion ici a été de trouver une convention de stockage afin de stocker la carte avec toutes ses propriétés afin de nous simplifier au maximum les phases de d'écriture et de lecture.
Nous avons donc choisi de procéder comme suivant : 
\begin{itemize}
\item Hauteur de la carte
\item Largeur de la carte
\item Nombre d'objets
\item Matrice de la carte (identifiant de l'objet)
\end{itemize}
Puis pour chaque objet : 
\begin{itemize}
\item Taille de la chaine de caractère du nom de l'objet 
\item Nom de l'objet 
\item Caractéritiques de l'objet.
\end{itemize}
\subsection{Sauvegarde}

	Concernant la sauvegarde, elle fonctionne partiellement. La sauvegarde en elle même ne pose aucun problème. Cependant, ils nous a été impossible de sauvegarder tous les objets de la carte en incluant ceux qui ne sont pas présents physiquement sur la carte. Elle ne concerne donc que les objets ayant une présence physique sur la carte.
	Elle fonctionne de la manière suivante. En premier lieu des appels aux fonctions permettant de récupérer largeur et hauteurs sont effectués. Ces deux valeurs sont inscrites directement dans le fichier via la fonction \textit{write()}. Un tableau d'objets est ensuite crée afin de répertorier tous les objets différents. Il nous permettra via son parcours d'écrire les caractéritiques des objets. Une double boucle \textit{for} parcours ensuite toute la carte. Chaque objet est récupéré via la fonction \textit{map\_get(x,y)} et est stocké dans le tableau \textit{tab\_carte}. Ce tableau est de taille \textit{largeur * hauteur} et va contenir toute la matrice. Avoir un tableau de cette taille nous permet de n'avoir recours qu'à un seul appel à la fonction \textit{write()} Pour chaque objet, on regarde alors si il est nouveau. Si oui, il est ajouté au tableau des objets et le nombre d'objets est alors incrémenté.
	A la fin de ce parcours le nombre d'objets ainsi que le tableau \textit{tab\_carte} sont écrits dans le fichier de sauvegarde.
	
	Par la suite, un tableau de caractétiques est créé. De manière analogue au tableau de la carte, ce tableau nous permet de n'effectuer qu'un seul write par objet. Un boucle ayant pour longueur le nombre d'objets parcours le tableau d'objets. On récupère d'abord le nom de l'objet via la méthode \textit{map\_get\_name()} ensuite est calculé la longueur de ce nom via la fonction \textit{strlen()}. Une fois ceci fait, chaque case du tableau de caractéristiques sera rempli avec une caractéristique via les appels de fonctions correspondant. En fin de boucle sont écrits la taille du nom, le nom de l'objet et le tableau de caractéristiques.
	
\subsection{Chargement}

\section{maputil}
    Dans le main de maputil, on vérifie d'abord que le nombre d'arguments est d'au moins 2, puis on compare le deuxième argument aux différentes actions possibles. Et on vérifie également les erreurs possibles, comme l'ouverture du fichier map ou une erreurs dans les arguments.
\subsection{getwidth, height, objects, info}
    Chaque fonction get, se contente de se placer à la bonne position dans le fichier map et de renvoyer la valeur de la fonction lireEntierPositif, qui appel read et qui vérifie si il y a une erreur. Puis on affiche, tout en testant le retour de la fonction get. 
\subsection{Remplacement des objets d'une carte}
        \subsubsection{Fonction de verification des arguments}
            Avant d'appeler la fonction setObjects, on va d'abord verifier les arguments avec la fonction verificationArgumentsSetObjects.
            Dans cette fonction on vérfie d'abord si le nombre d'arguments est bon, donc pour ça on vérfifie d'abord si c'est un multiple 6, puisque l'utilisateur doit envoyer le nom de l'objet suivie des caractéristiques, ce qui fait plusieurs paquet de 6, de plus il faut vérifier que le nombre d'objets actuellement sur la carte est inférieur ou égale au nombre d'objets que l'utilisateur passe en parametre. Si la taille des arguments n'est pas bonne on renvoie ERRTAILLE
            
            Puis on vérifie les noms des arguments, pour ça, on vérifie si c'est bien un chiffre après le nom de l'image (le chiffre est la valeur de frame), donc pour ça, dans la boucle du parcours des arguments, si i est un multiple de 6 alors c'est que c'est une image et donc l'élement suivant doit être un chiffre, si ce n'est pas un chiffre on renvoie ERRNOM.
            Ensuite on vérifie les arguments suivants, pour ça on utilise un tableau qui contient les noms "solid", "air", "collectible" ... et donc on compare les arguments avec les élements du tableau, si on ne retrouve pas l'argument dans le tableau on renvoie ERRNOM.
            
        \subsubsection{Fonction setobjects}
            L'idée globale de la fonction c'est de supprimer dans le fichier tout sauf la hauteur et la largeur, pour pouvoir changer le nombre d'objet, et écrire la nouvelle liste.
            
            Pour ça on commence par se placer dans le fichier, au début de la matrice de la carte, puis on sauvegarde la matrice en lisant ligne par ligne (puisque on sait qu'une ligne est de taille largeur*sizeof(int) octets).
            Ensuite on supprime le contenu du fichier sans supprimer les 2*sizeof(int) premier octets (qui sont la largeur et la hauteur), puis on écrit à la fin du fichier map la nouvelle valeur du nombre d'objet et la matrice.
            
            Enfin on écrit la nouvelle liste, pour ça on a une boucle qui va de 0 au nombre d'arguments, si i est un multiple de 6, alors c'est qu'on a une chaîne de caractère à écrire, donc comme notre convention l'exige, on doit écrire, dans le fichier map, la taille de la chaine. Donc on écrit la taille de la chaine, puis la chaine, puis le frame. On écrit le frame directement ici car il est traité différement des autres arguments.
            Pour les autres arguments, on parcout le tableau des caracteristiques, si l'argument est à l'index 0, 1 ou 2  on écrit 0, 1 ou 2 puisque c'est soit "solid" soit "semi-solid" soit "air". Si l'argument est à l'index 3,4 ou 5 on écrit 1 puisque c'est "collectible", "destructible" ou "generator", et sinon on écrit 0. 
            
        
    
    
\section{Gestion des temporisateurs}


\end{document}
